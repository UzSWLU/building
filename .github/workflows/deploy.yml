name: ğŸš€ Deploy to Production

on:
  push:
    branches: [main]
    paths-ignore:
      - "**.md"
      - "docs/**"
  workflow_dispatch:
    inputs:
      environment:
        description: "Deployment environment"
        required: true
        default: "production"
        type: choice
        options:
          - production
          - staging

jobs:
  test:
    name: ğŸ§ª Run Tests
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_DB: building_test
          POSTGRES_USER: building
          POSTGRES_PASSWORD: building
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.12"

      - name: ğŸ“¦ Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: ğŸ—„ï¸ Install PostgreSQL client
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client

      - name: ğŸ”§ Setup test environment
        run: |
          cp env.prod.example .env.test
          echo "DJANGO_SECRET_KEY=test-secret-key-for-ci" >> .env.test
          echo "DJANGO_DEBUG=1" >> .env.test
          echo "DJANGO_ALLOWED_HOSTS=localhost,127.0.0.1" >> .env.test
          echo "POSTGRES_DB=building_test" >> .env.test
          echo "POSTGRES_USER=building" >> .env.test
          echo "POSTGRES_PASSWORD=building" >> .env.test
          echo "POSTGRES_HOST=localhost" >> .env.test
          echo "POSTGRES_PORT=5432" >> .env.test
          echo "AUTH_BASE_URL=https://auth.uzswlu.uz" >> .env.test

      - name: ğŸ—„ï¸ Create test database
        run: |
          # Wait for PostgreSQL to be ready
          until pg_isready -h localhost -p 5432 -U building; do
            echo "Waiting for PostgreSQL..."
            sleep 2
          done

          # Check if database exists, create if not
          if PGPASSWORD=building psql -h localhost -U building -lqt | cut -d \| -f 1 | grep -qw building_test; then
            echo "âœ… Test database already exists"
          else
            echo "ğŸ“ Creating test database..."
            PGPASSWORD=building createdb -h localhost -U building building_test
            echo "âœ… Test database created"
          fi

      - name: ğŸ—„ï¸ Run migrations
        run: python manage.py migrate
        env:
          DJANGO_SETTINGS_MODULE: project_core.settings
          POSTGRES_DB: building_test
          POSTGRES_USER: building
          POSTGRES_PASSWORD: building
          POSTGRES_HOST: localhost
          POSTGRES_PORT: 5432

      - name: ğŸ§ª Run tests
        run: |
          python manage.py test app_rttm
        env:
          DJANGO_SETTINGS_MODULE: project_core.settings
          POSTGRES_DB: building_test
          POSTGRES_USER: building
          POSTGRES_PASSWORD: building
          POSTGRES_HOST: localhost
          POSTGRES_PORT: 5432

      - name: ğŸ“Š Check code quality
        run: |
          python manage.py check
          python manage.py check --deploy
        env:
          DJANGO_SETTINGS_MODULE: project_core.settings
          POSTGRES_DB: building_test
          POSTGRES_USER: building
          POSTGRES_PASSWORD: building
          POSTGRES_HOST: localhost
          POSTGRES_PORT: 5432

  deploy:
    name: ğŸš€ Deploy to Production
    runs-on: [self-hosted, Linux, X64]
    needs: test
    timeout-minutes: 10

    steps:
      - name: ğŸ“¥ Pull latest code
        run: |
          cd /var/www/building-api

          # Fix git ownership and permissions
          echo "ğŸ”§ Fixing git ownership and permissions..."
          git config --global --add safe.directory /var/www/building-api

          # Fix git directory permissions
          sudo chown -R deploy:deploy /var/www/building-api/.git
          chmod -R 755 /var/www/building-api/.git

          echo "ğŸ“¥ Pulling latest code..."
          git fetch origin main
          git reset --hard origin/main

      - name: ğŸ”§ Update environment variables
        run: |
          cd /var/www/building-api

          echo "ğŸ” Checking .env.production..."
          if [ ! -f .env.production ]; then
            echo "ğŸ“ Creating .env.production from template..."
            cp env.prod.example .env.production
          fi

          # Create complete environment file
          echo "# Production Environment Variables for Building API" > .env.production
          echo "" >> .env.production
          echo "# Django Settings" >> .env.production
          echo "DJANGO_SECRET_KEY=django-insecure-production-secret-key-change-this-in-production" >> .env.production
          echo "DJANGO_DEBUG=0" >> .env.production
          echo "DJANGO_ALLOWED_HOSTS=building.swagger.uzswlu.uz" >> .env.production
          echo "" >> .env.production
          echo "# Database Settings" >> .env.production
          echo "POSTGRES_DB=building" >> .env.production
          echo "POSTGRES_USER=building" >> .env.production
          echo "POSTGRES_PASSWORD=building_production_password_2024" >> .env.production
          echo "POSTGRES_HOST=db" >> .env.production
          echo "POSTGRES_PORT=5432" >> .env.production
          echo "" >> .env.production
          echo "# Auth Service" >> .env.production
          echo "AUTH_BASE_URL=https://auth.uzswlu.uz" >> .env.production
          echo "AUTH_TIMEOUT=10" >> .env.production
          echo "AUTH_CACHE_TIMEOUT=300" >> .env.production
          echo "" >> .env.production
          echo "# OAuth URLs" >> .env.production
          echo "BACKEND_URL=https://auth.uzswlu.uz" >> .env.production
          echo "FRONTEND_CALLBACK_URL=https://building.swagger.uzswlu.uz/callback,http://localhost:5001/callback" >> .env.production
          echo "" >> .env.production
          echo "# Server Settings" >> .env.production
          echo "SERVER_HOST=172.22.0.19" >> .env.production
          echo "SERVER_USER=root" >> .env.production
          echo "SERVER_PORT=22" >> .env.production

          echo "âœ… Environment configured:"
          cat .env.production

      - name: ğŸ³ Build and deploy
        run: |
          cd /var/www/building-api

          echo "ğŸ›‘ Stopping existing containers..."
          docker-compose -f docker-compose.prod.yml down -v

          echo "ğŸ”¨ Building new containers..."
          docker-compose -f docker-compose.prod.yml build --no-cache

          echo "ğŸš€ Starting services..."
          docker-compose -f docker-compose.prod.yml up -d

          echo "â³ Waiting for services to start..."
          sleep 30

      - name: ğŸ—„ï¸ Run database migrations
        run: |
          cd /var/www/building-api
          echo "ğŸ—„ï¸ Running database migrations..."
          docker-compose -f docker-compose.prod.yml exec -T web python manage.py migrate

          echo "ğŸ“Š Creating superuser if not exists..."
          docker-compose -f docker-compose.prod.yml exec -T web python manage.py shell -c "
          from django.contrib.auth import get_user_model
          User = get_user_model()
          if not User.objects.filter(username='admin').exists():
              User.objects.create_superuser('admin', 'admin@uzswlu.uz', 'admin123')
              print('Superuser created')
          else:
              print('Superuser already exists')
          "

      - name: ğŸ“Š Collect static files
        run: |
          cd /var/www/building-api
          echo "ğŸ“Š Collecting static files..."
          docker-compose -f docker-compose.prod.yml exec -T web python manage.py collectstatic --noinput

      - name: ğŸ¥ Health check
        run: |
          cd /var/www/building-api
          echo "ğŸ¥ Performing health checks..."

          # Wait for services to be ready
          sleep 10

          # Check container status
          echo "ğŸ“Š Container Status:"
          docker-compose -f docker-compose.prod.yml ps

          # Test API endpoints
          echo "ğŸ” Testing API endpoints..."

          # Health check (domain)
          curl -f https://building.swagger.uzswlu.uz/health/ || echo "âš ï¸ Health check failed"

          # Swagger UI (domain)
          curl -f https://building.swagger.uzswlu.uz/ || echo "âš ï¸ Swagger UI check failed"

          # API schema (domain)
          curl -f https://building.swagger.uzswlu.uz/api/schema/ || echo "âš ï¸ API schema check failed"

      - name: ğŸ“ Display logs
        if: always()
        run: |
          cd /var/www/building-api
          echo "ğŸ“ Recent application logs:"
          docker-compose -f docker-compose.prod.yml logs --tail=50 web

      - name: âœ… Deployment success
        run: |
          echo "âœ… =============================================="
          echo "âœ… BUILDING API DEPLOYED SUCCESSFULLY!"
          echo "âœ… =============================================="
          echo ""
          echo "ğŸŒ Production URLs:"
          echo "ğŸ”— API: https://building.swagger.uzswlu.uz/"
          echo "ğŸ”— Swagger UI: https://building.swagger.uzswlu.uz/"
          echo "ğŸ”— Health Check: https://building.swagger.uzswlu.uz/health/"
          echo "ğŸ”— API Schema: https://building.swagger.uzswlu.uz/api/schema/"
          echo "ğŸ”— Admin: https://building.swagger.uzswlu.uz/admin/"
          echo ""
          echo "ğŸ“Š Container Status:"
          docker-compose -f docker-compose.prod.yml ps
