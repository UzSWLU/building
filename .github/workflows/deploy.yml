name: üöÄ Deploy to Production

on:
  push:
    branches: [main]
    paths-ignore:
      - "**.md"
      - "docs/**"
  workflow_dispatch:
    inputs:
      environment:
        description: "Deployment environment"
        required: true
        default: "production"
        type: choice
        options:
          - production
          - staging
      force_deploy:
        description: "Force deployment even if no changes"
        required: false
        default: false
        type: boolean

jobs:
  test:
    name: üß™ Run Tests
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_DB: building_test
          POSTGRES_USER: building
          POSTGRES_PASSWORD: building
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üêç Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.12"

      - name: üì¶ Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: üóÑÔ∏è Install PostgreSQL client
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client

      - name: üîß Setup test environment
        run: |
          cp env.prod.example .env.test
          echo "DJANGO_SECRET_KEY=test-secret-key-for-ci" >> .env.test
          echo "DJANGO_DEBUG=1" >> .env.test
          echo "DJANGO_ALLOWED_HOSTS=localhost,127.0.0.1" >> .env.test
          echo "POSTGRES_DB=building_test" >> .env.test
          echo "POSTGRES_USER=building" >> .env.test
          echo "POSTGRES_PASSWORD=building" >> .env.test
          echo "POSTGRES_HOST=localhost" >> .env.test
          echo "POSTGRES_PORT=5432" >> .env.test
          echo "AUTH_BASE_URL=https://auth.uzswlu.uz" >> .env.test

      - name: üóÑÔ∏è Create test database
        run: |
          # Wait for PostgreSQL to be ready
          until pg_isready -h localhost -p 5432 -U building; do
            echo "Waiting for PostgreSQL..."
            sleep 2
          done

          # Check if database exists, create if not
          if PGPASSWORD=building psql -h localhost -U building -lqt | cut -d \| -f 1 | grep -qw building_test; then
            echo "‚úÖ Test database already exists"
          else
            echo "üìù Creating test database..."
            PGPASSWORD=building createdb -h localhost -U building building_test
            echo "‚úÖ Test database created"
          fi

      - name: üóÑÔ∏è Run migrations
        run: python manage.py migrate
        env:
          DJANGO_SETTINGS_MODULE: project_core.settings
          POSTGRES_DB: building_test
          POSTGRES_USER: building
          POSTGRES_PASSWORD: building
          POSTGRES_HOST: localhost
          POSTGRES_PORT: 5432

      - name: üß™ Run tests
        run: |
          python manage.py test app_rttm
        env:
          DJANGO_SETTINGS_MODULE: project_core.settings
          POSTGRES_DB: building_test
          POSTGRES_USER: building
          POSTGRES_PASSWORD: building
          POSTGRES_HOST: localhost
          POSTGRES_PORT: 5432

      - name: üìä Check code quality
        run: |
          python manage.py check
          python manage.py check --deploy
        env:
          DJANGO_SETTINGS_MODULE: project_core.settings
          POSTGRES_DB: building_test
          POSTGRES_USER: building
          POSTGRES_PASSWORD: building
          POSTGRES_HOST: localhost
          POSTGRES_PORT: 5432

  deploy:
    name: üöÄ Deploy to Production
    runs-on: [self-hosted, Linux, X64]
    needs: test
    timeout-minutes: 10
    # Run as root user to avoid permission issues
    container:
      image: ubuntu:22.04
      options: --user root

    steps:
      - name: üì¶ Install required packages
        run: |
          echo "üì¶ Installing required packages..."
          apt-get update
          apt-get install -y git curl wget

          # Install Docker Compose
          curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          chmod +x /usr/local/bin/docker-compose

          echo "‚úÖ Packages installed successfully"

      - name: üì• Setup and pull latest code
        run: |
          # Create directory if it doesn't exist
          echo "üìÅ Creating directory structure..."
          mkdir -p /var/www/building-api
          cd /var/www/building-api

          # Check if repository exists, clone if not
          if [ ! -d ".git" ]; then
            echo "üì• Cloning repository..."
            git clone https://github.com/a-d-sh/building.git .
          else
            echo "üì• Pulling latest code..."
            git fetch origin main
            git reset --hard origin/main
          fi

          # Fix git ownership and permissions
          echo "üîß Fixing git ownership and permissions..."
          git config --global --add safe.directory /var/www/building-api

          # Fix permissions for entire directory
          echo "üîß Fixing directory permissions..."
          chmod -R 755 . 2>/dev/null || echo "‚ö†Ô∏è Could not change directory permissions, continuing..."

          # Ensure deploy user owns all files
          echo "üîß Fixing file ownership..."
          chown -R deploy:deploy . 2>/dev/null || echo "‚ö†Ô∏è Could not change file ownership, continuing..."

      - name: üîß Update environment variables
        run: |
          cd /var/www/building-api

          echo "üîç Checking .env.prod file..."
          if [ ! -f .env.prod ]; then
            echo "üìù Creating .env.prod from template..."
            if [ -f env.prod.example ]; then
              cp env.prod.example .env.prod
            else
              echo "‚ö†Ô∏è env.prod.example not found, creating basic .env.prod"
            fi
          fi

          # Create complete environment file
          echo "# Production Environment Variables for Building API" > .env.prod
          echo "" >> .env.prod
          echo "# Django Settings" >> .env.prod
          echo "DJANGO_SECRET_KEY=django-insecure-production-secret-key-change-this-in-production" >> .env.prod
          echo "DJANGO_DEBUG=0" >> .env.prod
          echo "DJANGO_ALLOWED_HOSTS=api.uzswlu.uz,172.22.0.19,localhost,127.0.0.1" >> .env.prod
          echo "CSRF_TRUSTED_ORIGINS=https://front.uzswlu.uz,https://building.api.uzswlu.uz,https://api.uzswlu.uz,https://uzswlu.uz,http://localhost:3003,http://172.22.0.19:5001" >> .env.prod
          echo "" >> .env.prod
          echo "# Domain Configuration" >> .env.prod
          echo "API_DOMAIN=api.uzswlu.uz" >> .env.prod
          echo "API_PORT=5001" >> .env.prod
          echo "" >> .env.prod
          echo "# Database Settings" >> .env.prod
          echo "POSTGRES_DB=building" >> .env.prod
          echo "POSTGRES_USER=building" >> .env.prod
          echo "POSTGRES_PASSWORD=building_production_password_2024" >> .env.prod
          echo "POSTGRES_HOST=db" >> .env.prod
          echo "POSTGRES_PORT=5432" >> .env.prod
          echo "" >> .env.prod
          echo "# Auth Service" >> .env.prod
          echo "AUTH_BASE_URL=https://auth.uzswlu.uz" >> .env.prod
          echo "AUTH_TIMEOUT=10" >> .env.prod
          echo "AUTH_CACHE_TIMEOUT=300" >> .env.prod
          echo "" >> .env.prod
          echo "# OAuth URLs" >> .env.prod
          echo "BACKEND_URL=https://auth.uzswlu.uz" >> .env.prod
          echo "FRONTEND_CALLBACK_URL=https://building.swagger.uzswlu.uz/callback,http://localhost:5001/callback" >> .env.prod
          echo "" >> .env.prod
          echo "# Server Settings" >> .env.prod
          echo "SERVER_HOST=172.22.0.19" >> .env.prod
          echo "SERVER_USER=root" >> .env.prod
          echo "SERVER_PORT=22" >> .env.prod

          echo "‚úÖ Environment configured:"
          cat .env.prod

      - name: üê≥ Complete deploy
        run: |
          cd /var/www/building-api

          echo "üîç Checking current containers..."
          docker-compose -f docker-compose.prod.yml ps || true

          echo "üõë SAFE CLEANUP - Only building-api containers..."

          # Stop and remove only building-api containers
          echo "üõë Stopping building-api containers..."
          docker-compose -f docker-compose.prod.yml down -v --remove-orphans || true

          # Remove only building-api related containers
          echo "üõë Removing building-api containers..."
          docker ps -a --filter "name=building-api" --format "{{.ID}}" | xargs -r docker rm -f || true

          # Remove only building-api related volumes
          echo "üõë Removing building-api volumes..."
          docker volume ls --filter "name=building" --format "{{.Name}}" | xargs -r docker volume rm || true

          # Remove specific building-api volumes
          echo "üõë Removing specific building-api volumes..."
          docker volume rm building-api_db_data 2>/dev/null || true
          docker volume rm building-api_static_volume 2>/dev/null || true
          docker volume rm building-api_media_volume 2>/dev/null || true

          # Remove only building-api related networks
          echo "üõë Removing building-api networks..."
          docker network ls --filter "name=building" --format "{{.Name}}" | xargs -r docker network rm || true

          echo "üîç Checking port 5001 usage..."
          netstat -tulpn | grep :5001 || echo "Port 5001 is free"

          echo "‚è≥ Waiting for complete cleanup..."
          sleep 2

          echo "üî® Building web container (with cache)..."
          # Use cache for faster builds, only rebuild if Dockerfile changed
          docker-compose -f docker-compose.prod.yml build --parallel web

          echo "üóÑÔ∏è Starting database first..."
          docker-compose -f docker-compose.prod.yml up -d db

          echo "‚è≥ Waiting for database to initialize..."
          sleep 10

          echo "üîç Checking database container status..."
          docker-compose -f docker-compose.prod.yml ps db

          echo "üöÄ Starting all services..."
          docker-compose -f docker-compose.prod.yml up -d

          echo "‚è≥ Waiting for services to start..."
          sleep 10

          echo "üîç Checking final container status..."
          docker-compose -f docker-compose.prod.yml ps

      - name: üóÑÔ∏è Run database migrations
        run: |
          cd /var/www/building-api
          echo "üóÑÔ∏è Running database migrations..."

          echo "üîç Checking database container status..."
          docker-compose -f docker-compose.prod.yml ps

          echo "‚è≥ Waiting for database container to be healthy..."
          for i in $(seq 1 30); do
            echo "Attempt $i/30: Checking database status..."
            DB_STATUS=$(docker-compose -f docker-compose.prod.yml ps db | grep -E "(Up|healthy)" || echo "not_ready")
            if echo "$DB_STATUS" | grep -q "Up"; then
              echo "‚úÖ Database container is running!"
              break
            fi
            echo "‚è≥ Database not ready yet, waiting 10 seconds..."
            sleep 10
          done

          echo "üîç Final database container status..."
          docker-compose -f docker-compose.prod.yml ps

          echo "üóÑÔ∏è Running migrations..."
          docker-compose -f docker-compose.prod.yml exec -T web python manage.py migrate

          echo "üìä Creating superuser if not exists..."
          docker-compose -f docker-compose.prod.yml exec -T web python manage.py shell -c "
          from django.contrib.auth import get_user_model
          User = get_user_model()
          if not User.objects.filter(username='admin').exists():
              User.objects.create_superuser('admin', 'admin@uzswlu.uz', 'admin123')
              print('Superuser created')
          else:
              print('Superuser already exists')
          "

      - name: üìä Collect static files
        run: |
          cd /var/www/building-api
          echo "üìä Collecting static files..."
          docker-compose -f docker-compose.prod.yml exec -T web python manage.py collectstatic --noinput

      - name: üè• Health check
        run: |
          cd /var/www/building-api
          echo "üè• Performing health checks..."

          # Wait for services to be ready
          sleep 5

          # Check container status
          echo "üìä Container Status:"
          docker-compose -f docker-compose.prod.yml ps

          # Test API endpoints
          echo "üîç Testing API endpoints..."

          # Health check (Domain)
          curl -f http://api.uzswlu.uz/health/ || echo "‚ö†Ô∏è Health check failed"

          # Swagger UI (Domain)
          curl -f http://api.uzswlu.uz/ || echo "‚ö†Ô∏è Swagger UI check failed"

          # API schema (Domain)
          curl -f http://api.uzswlu.uz/api/schema/ || echo "‚ö†Ô∏è API schema check failed"

      - name: üìù Display logs
        if: always()
        run: |
          cd /var/www/building-api
          echo "üìù Recent application logs:"
          docker-compose -f docker-compose.prod.yml logs --tail=50 web

      - name: üîç Check DNS and Nginx configuration
        run: |
          echo "üîç Checking DNS and Nginx configuration..."

          # Check DNS resolution (skip if tools not available)
          echo "üì° DNS Resolution Test:"
          if command -v nslookup >/dev/null 2>&1; then
            nslookup api.uzswlu.uz || echo "‚ö†Ô∏è DNS resolution failed"
            nslookup auth.uzswlu.uz || echo "‚ö†Ô∏è DNS resolution failed"
          else
            echo "‚ö†Ô∏è nslookup not available in container"
          fi

          # Check server Nginx configuration (skip if not available)
          echo "üåê Server Nginx Configuration:"
          if [ -d "/etc/nginx/sites-enabled" ]; then
            echo "üìÅ Sites enabled:"
            ls -la /etc/nginx/sites-enabled/
          else
            echo "‚ö†Ô∏è Server-level Nginx not available in container"
          fi

          # Check what api.uzswlu.uz currently serves
          echo "üîç Checking what api.uzswlu.uz currently serves:"
          curl -s http://api.uzswlu.uz/ | head -10 || echo "‚ö†Ô∏è Could not get api.uzswlu.uz content"

          # Check what auth.uzswlu.uz serves
          echo "üîç Checking what auth.uzswlu.uz serves:"
          curl -s http://auth.uzswlu.uz/ | head -10 || echo "‚ö†Ô∏è Could not get auth.uzswlu.uz content"

          # Check Nginx configuration
          echo "üåê Building API Nginx Configuration Test:"
          cd /var/www/building-api
          docker-compose -f docker-compose.prod.yml exec nginx nginx -t || echo "‚ö†Ô∏è Nginx config test failed"

          # Check if domain is accessible
          echo "üåç Domain Accessibility Test:"
          curl -I --connect-timeout 10 --max-time 15 http://api.uzswlu.uz/ || echo "‚ö†Ô∏è Domain not accessible"
          curl -I --connect-timeout 10 --max-time 15 http://172.22.0.19:5001/ || echo "‚ö†Ô∏è Direct IP:port not accessible"

          # Check if we need to fix server Nginx configuration
          echo "üîß Checking if api.uzswlu.uz needs to be redirected to port 5001..."
          if curl -s http://api.uzswlu.uz/ | grep -q "auth"; then
            echo "‚ö†Ô∏è api.uzswlu.uz is currently serving auth-api, need to fix!"
            echo "üìù Creating Nginx configuration to redirect api.uzswlu.uz to port 5001..."
            
            # Create Nginx configuration for api.uzswlu.uz
            echo "server {" > /etc/nginx/sites-available/api.uzswlu.uz
            echo "    listen 80;" >> /etc/nginx/sites-available/api.uzswlu.uz
            echo "    server_name api.uzswlu.uz;" >> /etc/nginx/sites-available/api.uzswlu.uz
            echo "    " >> /etc/nginx/sites-available/api.uzswlu.uz
            echo "    location / {" >> /etc/nginx/sites-available/api.uzswlu.uz
            echo "        proxy_pass http://127.0.0.1:5001;" >> /etc/nginx/sites-available/api.uzswlu.uz
            echo "        proxy_set_header Host \$host;" >> /etc/nginx/sites-available/api.uzswlu.uz
            echo "        proxy_set_header X-Real-IP \$remote_addr;" >> /etc/nginx/sites-available/api.uzswlu.uz
            echo "        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;" >> /etc/nginx/sites-available/api.uzswlu.uz
            echo "        proxy_set_header X-Forwarded-Proto \$scheme;" >> /etc/nginx/sites-available/api.uzswlu.uz
            echo "        proxy_redirect off;" >> /etc/nginx/sites-available/api.uzswlu.uz
            echo "        " >> /etc/nginx/sites-available/api.uzswlu.uz
            echo "        # Timeouts" >> /etc/nginx/sites-available/api.uzswlu.uz
            echo "        proxy_connect_timeout 30s;" >> /etc/nginx/sites-available/api.uzswlu.uz
            echo "        proxy_send_timeout 30s;" >> /etc/nginx/sites-available/api.uzswlu.uz
            echo "        proxy_read_timeout 30s;" >> /etc/nginx/sites-available/api.uzswlu.uz
            echo "    }" >> /etc/nginx/sites-available/api.uzswlu.uz
            echo "}" >> /etc/nginx/sites-available/api.uzswlu.uz
            
            # Enable the site
            ln -sf /etc/nginx/sites-available/api.uzswlu.uz /etc/nginx/sites-enabled/
            
            # Test and reload Nginx
            nginx -t && nginx -s reload
            echo "‚úÖ Nginx configuration updated for api.uzswlu.uz"
          else
            echo "‚úÖ api.uzswlu.uz is already correctly configured"
          fi

          # Auto-configure server-level Nginx and SSL certificates
          echo "üîß Auto-configuring server-level Nginx and SSL..."
          
          # Create HTTP configuration first
          echo "üìù Creating HTTP configuration..."
          sudo rm -f /etc/nginx/sites-available/api.uzswlu.uz
          echo "# HTTP -> HTTPS redirect" | sudo tee /etc/nginx/sites-available/api.uzswlu.uz
          echo "server {" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "    listen 80;" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "    server_name api.uzswlu.uz;" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "    " | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "    # Let's Encrypt validation" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "    location /.well-known/acme-challenge/ {" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "        root /var/www/html;" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "    }" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "    " | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "    # Redirect all other requests to HTTPS" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "    location / {" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "        return 301 https://\$server_name\$request_uri;" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "    }" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "}" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "# HTTPS server" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "server {" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "    listen 443 ssl http2;" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "    server_name api.uzswlu.uz;" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "    " | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "    # SSL Configuration (using existing certificates)" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "    ssl_certificate /etc/nginx/ssl/STAR25_uzswlu_uz.crt;" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "    ssl_certificate_key /etc/nginx/ssl/STAR25_uzswlu_uz.key;" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "    ssl_protocols TLSv1.2 TLSv1.3;" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "    ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384';" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "    ssl_prefer_server_ciphers off;" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "    ssl_session_cache shared:SSL:10m;" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "    ssl_session_timeout 10m;" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "    ssl_session_tickets off;" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "    " | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "    # Security Headers" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "    add_header Strict-Transport-Security \"max-age=31536000; includeSubDomains\" always;" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "    add_header X-Frame-Options \"SAMEORIGIN\" always;" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "    add_header X-Content-Type-Options \"nosniff\" always;" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "    add_header X-XSS-Protection \"1; mode=block\" always;" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "    " | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "    # Client max body size" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "    client_max_body_size 20M;" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "    " | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "    # Proxy to building API" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "    location / {" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "        proxy_pass http://127.0.0.1:5001;" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "        proxy_set_header Host \$host;" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "        proxy_set_header X-Real-IP \$remote_addr;" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "        proxy_set_header X-Forwarded-Proto \$scheme;" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "        proxy_redirect off;" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "        " | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "        # Timeouts" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "        proxy_connect_timeout 30s;" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "        proxy_send_timeout 30s;" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "        proxy_read_timeout 30s;" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "    }" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "    " | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "    # Health check endpoint" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "    location /health/ {" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "        proxy_pass http://127.0.0.1:5001;" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "        access_log off;" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "    }" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          echo "}" | sudo tee -a /etc/nginx/sites-available/api.uzswlu.uz
          
          # Enable the site
          sudo ln -sf /etc/nginx/sites-available/api.uzswlu.uz /etc/nginx/sites-enabled/
          
          # Test Nginx configuration
          sudo nginx -t
          
          # Reload Nginx
          sudo nginx -s reload
          
          echo "‚úÖ HTTP configuration created and enabled"
          
          # Use existing SSL certificates from /var/www/sertifikat
          echo "üîí Using existing SSL certificates..."
          if [ -d "/var/www/sertifikat" ]; then
            echo "‚úÖ SSL certificates directory found: /var/www/sertifikat"
            ls -la /var/www/sertifikat/
          else
            echo "‚ö†Ô∏è SSL certificates directory not found: /var/www/sertifikat"
            echo "Please ensure SSL certificates are available in /var/www/sertifikat/"
          fi

      - name: ‚úÖ Deployment success
        run: |
          echo "‚úÖ =============================================="
          echo "‚úÖ BUILDING API DEPLOYED SUCCESSFULLY!"
          echo "‚úÖ =============================================="
          echo ""
          echo "üåê Production URLs:"
          echo "üîó API: http://172.22.0.19:5001/"
          echo "üîó Swagger UI: http://172.22.0.19:5001/"
          echo "üîó Health Check: http://172.22.0.19:5001/health/"
          echo "üîó API Schema: http://172.22.0.19:5001/api/schema/"
          echo "üîó Admin: http://172.22.0.19:5001/admin/"
          echo ""
          echo "üåê Domain URLs (with SSL certificates):"
          API_DOMAIN=$(grep "API_DOMAIN=" .env.prod | cut -d'=' -f2)
          echo "üîó API: https://${API_DOMAIN}/"
          echo "üîó Swagger UI: https://${API_DOMAIN}/"
          echo "üîó Health Check: https://${API_DOMAIN}/health/"
          echo "üîó API Schema: https://${API_DOMAIN}/api/schema/"
          echo "üîó Admin: https://${API_DOMAIN}/admin/"
          echo ""
          echo "üîí SSL Certificate: Automatically installed and auto-renewing"
          echo "üîÑ HTTP ‚Üí HTTPS: Automatic redirect configured"
          echo ""
          echo "üìä Container Status:"
          cd /var/www/building-api
          docker-compose -f docker-compose.prod.yml ps || echo "‚ö†Ô∏è Could not get container status"
